\begin{wrapfigure}[10]{r}{0.25\textwidth}
  \vspace{-2em}
  \begin{center}
    \includegraphics[width=\linewidth]{3d-roof.tikz}
  \end{center}
  \caption{%
    \\
    Three-dimensional\\polygonal gable roof.
  }%
  \label{fig:gable-roof}
\end{wrapfigure}

The roof of a given building can be decomposed into a collection of entirely flat polygons.
This is an accurate data decomposition in most cases, the exception being conic shapes and other surfaces with continuous curvature which cannot be perfectly represented with a finite set of flat polygons.
A \emph{gable roof}\footnote{\textit{Gable roof} -- A roof which consists of two flat roof surfaces which slope in opposite directions.
The roof surfaces are connected along the highest, horizontal edge (ridge).}, for instance, can be considered as the set of two flat polygons, which when combined together accurately represent the roof in its entirety.
Our intent is to construct a machine learning pipeline which is able to identify such three-dimensional roof surfaces from remote sensing data.

Although a set of vectorized, flat polygons is often the most suitable data representation for geometric roof data in the GIS world, it is \emph{not} considered an ideal representation for traditional machine vision data pipelines.
Polygons can consist of an arbitrary number of linear rings, each with an arbitrary number of vertices.
The number of rings and vertices depends on the complexity of the given polygon's shape.
Deep learning model architectures, on the other hand, are often restricted to training on and predicting observations of \emph{consistent} dimensionality.
This is why machine vision architectures most often accept and/or emit spatial information in the form of \emph{rasters} rather than vectors, that is, numeric arrays of consistent size.
In order to reconcile these conflicting requirements we now pose the following question:
%
\begin{quotation}
  \enquote{How can an arbitrarily sized set of three-dimensional polygons, all of arbitrary complexity, shape, and orientation, be accurately represented in the form of a raster?}.
\end{quotation}
%
The ideal raster format would allow us to train on and predict roof surfaces in vectorized polygon form, all the while applying the tried and tested techniques from the machine vision literature which mainly concerns itself with rasters.
We will refer to such a raster as a \textit{surface raster} in order to distinguish it from other remote sensing raster types such as aerial photography and LiDAR data.
The careful formulation and construction of this surface raster format is considered one of the most important problems to be solved in order to construct an efficient machine learning pipeline for predicting roof surfaces.
\begin{figure}
  \begin{center}
    \includegraphics{invertible-rasterization.tikz}
  \end{center}
  \vspace{-1.5em}
  \caption{Invertible rasterization}
  \label{fig:invertible-rasterization}
  \vspace{-1.5em}
\end{figure}

\subsection{Desirable surface raster properties}
The ideal surface raster format should be both \emph{representative} and \emph{targetable}, properties which we now shall formally define.
Start by denoting the domain which consists of polygon \textit{sets} of arbitrary cardinality as $V$.
A polygon in vector format will be denoted as $P$, while a set of vector polygons will be denoted as $\mathcal{P} = \{P_1, P_2, \dots\}$.
A vector polygon set $\mathcal{P}$ is therefore a member of the superset domain $V$, denoted as $\mathcal{P} \in V$.
Assume that we want to construct a surface raster of height $H$ and width $W$, and that this raster will consists of $C_R$ raster channels.
If we denote this surface raster domain as $R$ and assume that raster values will take values from the real number line then we have $R = \mathbb{R}^{H \times W \times C_R}$.
Finally, assume that the remote sensing raster data, $X$, has all the same dimensional properties as the surface raster data with the possible exception of the number of raster channels, which we will denote as $C_X$, i.e. $X \in \mathbb{R}^{H \times W \times C_X}$.
\begin{description}[style=nextline]
  \item[Representative]
    \textit{Converting surface polygons to the surface raster format and then back again incurs negligible loss of information.}
    \\
    Define a suitable distance metric $d: V \times V \rightarrow{R}$ which incorporates some notion of the difference in spatial location and orientation between two sets consisting three-dimensional polygons.
    A \emph{perfectly} \textit{representative} raster format would allow us to define a mapping from the vector domain to the surface raster domain, $m: V \rightarrow R$, for which there exists a functional inverse:
    \begin{align*}
      m^{-1}\left(m(\mathcal{P})\right)
      &\equiv
      \mathcal{P},
      &\forall \mathcal{P} \in V.
      \\
      \implies d\left(
        m^{-1}(m(\mathcal{P})),~\mathcal{P}
      \right)
      &\equiv
      0,
      &\forall \mathcal{P} \in V.
    \end{align*}
    The vector domain $V$ is infinite-dimensional, while the raster domain $R$ is by necessity of finite and consistent size.
    It can therefore be concluded that no such invertible mapping exists.
    For this reason we introduce the concept of a \textit{pseudo-inverse}, $m^{\dagger}$, a function which minimizes $d(m^{\dagger}(m(\mathcal{P})), \mathcal{P})$ for all $\mathcal{P} \in V$.
    A raster domain (and associated pseudo-invertible mapping) which produces negligible distance metrics is considered to be \textit{representative}.
  \item[Targetable] 
    \textit{A raster format which is feasible as a modelling target for a machine learning architecture.}
    \\
    We intend to construct a predictor, $\hat{f}$, which accepts remote sensing raster data as input and produces the aforementioned surface raster data representation as output, i.e.  $\hat{f}: V \rightarrow R$, or equivalently
    $
      \hat{f}:
        \mathbb{R}^{H \times W \times C_X}
        \rightarrow
        \mathbb{R}^{H \times W \times C_R}
    $.
    Now assume $\hat{f}$ to be parametrized according to the parameter vector $\vec{\theta}$, and denote the parametrized prediction as $\hat{Y} \defeq \hat{f}(X; \vec{\theta})$.
    The intention is that surface raster prediction $\hat{Y}$ generated from remote sensing data should be as similar to the polygon-constructed raster $Y \defeq m(\mathcal{P})$ as possible.
    Similar to the distance metric $d$ defined previously, we now define a suitable differentiable \textit{loss} function $\mathcal{L}: R \times R \rightarrow \mathbb{R}$ which incorporates some notion of difference between two surface rasters.
    The predictor $\hat{f}$ can therefore be parametrized such that this loss function is minimized when evaluated on the predicted surface raster in conjunction with the ground truth surface raster $m(P)$:
    \begin{align*}
      \vec{\theta}_{\mathrm{opt}}
      &\defeq
      \argmin_{\vec{\theta}}
      \sum_{(\hat{Y}, Y)}
      \mathcal{L}\left(
        \hat{Y};
        Y
      \right)
      \\
      &=
      \argmin_{\vec{\theta}}
      \sum_{(X, \mathcal{P})}
      \mathcal{L}\left(
        \hat{f}(X; \vec{\theta});
        m(\mathcal{P})
      \right)
    \end{align*}
    A raster mapping for which a suitable loss function can be constructed and minimized is considered to be \textit{targetable}.
\end{description}
The considerations of representativeness and targetability are in many ways diametrically opposed when constructing a suitable raster mapping.
As an instructive example consider the choice of $C_R$, the number of raster channels used by the surface raster.
Since the mapping $m$ maps from a infinite-dimensional space to a finite-dimensional one, it can be considered a compression method of sorts.
The smaller the value of $C_R$, the greater the compression, and subsequently its associated compression loss.
Thus the greater number of raster channels, the more representative the raster format can become.
On the other hand, when $C_R$ grows large it is natural to assume that the increasing degree of freedom in the data format allows for many equivalently accurate representations of the same polygon collection.
The raster format may also become more sparse as a result.
This ambiguity and sparseness will result in a difficulties when formulating a proper, convex loss function with single, global minima.
The targetability of the raster format may therefore suffer from large values of $C_R$.

Although it is the surface raster loss function we minimize in practice, it is actually not what we \emph{really} are interested in.
The surface raster is in essence only an intermediate data format which is intended to be converted back into the vector domain by the pseuo-inverse $m^{\dagger}$.
The thought is that if we minimize the difference between $\hat{Y}$ and $Y$, we implicitly minimize the difference between $m^{\dagger}(\hat{Y})$ and $P$.
This assumes that $\mathcal{L}$ is a good loss surrogate for functional composition $d \circ m^{\dagger}$, by which we mean that $\vec{\theta}_{\mathrm{opt}}$ also is a good minimizer for:
\begin{align*}
  \sum_{(X, \mathcal{P})}
  d\left(
    m^{\dagger}(m(\mathcal{P})),~
    m^{\dagger}(\hat{f}(X; \vec{\theta}))
  \right).
\end{align*}
For a sufficiently representative raster mapping this should also imply that $\vec{\theta}_{\mathrm{opt}}$ also is a good minimizer for:
\begin{align*}
  \sum_{(X, \mathcal{P})}
  d\left(
    \mathcal{P},~
    m^{\dagger}(\hat{f}(X; \vec{\theta}))
  \right).
\end{align*}
This is the metric we really intend to minimize, but can only do so implicitly with a good surrogate loss function, and a raster format that is sufficiently representative and targetable.

\subsection{The \enquote{surface normal} raster format}

We want to construct raster arrays (tiles) which represent different types of GIS data.
Each such raster tile represents GIS data corresponding to a specific geographic area, the extent of which is specified by a bounding box $B(\vec{c}, w, h)$.
In our case we intend to construct square tiles with areas of $\SI{4096}{\meter\squared}$, i.e. having width and height $w = h = \SI{64}{\meter}$.
All of the bounding boxes have centroids $\vec{c}$ such that they are situated within the Norwegian municipality of Trondheim.
Denote the set of all these bounding boxes as $\mathcal{T}$:
%
\begin{align*}
  \mathcal{T}
  &=
  \{
    B(\vec{c}_1, \SI{64}{\meter}, \SI{64}{\meter}),
    B(\vec{c}_2, \SI{64}{\meter}, \SI{64}{\meter}),
    \dots
    B(\vec{c}_{|\mathcal{T}|}, \SI{64}{\meter}, \SI{64}{\meter})
  \}
  \\
  &=
  \{
    B_1,
    B_2,
    \dots,
    B_{|\mathcal{T}|}
  \}
\end{align*}
%
Our bounding boxes are constructed from cadastral plots in Trondheim, totaling $|\mathcal{T}| = \numtiles$.
We will restrict ourselves to constructing raster arrays of consistent resolution height $H = 256$ and resolution width $W = 256$.
This results in $256^2$ \enquote{pixelized} GIS measurements per raster tile, or equivalently, \num{16} raster pixel values per meter squared.
A specific bounding box $B(\vec{c}, \SI{64}{\meter}, \SI{64}{\meter})$ will therefore be represented by a set of $256 \times 256 \times C$ raster arrays consisting of $C$ channels.
We have already described raster arrays representing different types of GIS data, such as RGB aerial photography ($C = 3$), LiDAR elevation data ($C = 1$), or building footprint segmentation masks ($C = 1$).
The idea is now to construct an entirely new raster format which is able to represent a set of three-dimensional polygons:
\begin{equation*}
  \mathcal{P}
  =
  \{
    P_1,
    P_2,
    \dots,
    P_{|\mathcal{P}|}
  \}.
\end{equation*}
In our case $\mathcal{P}$ consists of all roof surfaces in Trondheim, totaling $|\mathcal{P}| = \numsurfaces$.
Our surface raster format, which we will refer to as the \enquote{surface normal} raster, is intended as a format which is both representative and targetable.
We start by imposing two key assumptions on the polygons contained by $\mathcal{P}$.
\begin{enumerate}
  \item\label{itm:flat} All polygons $P \in \mathcal{P}$ are \textbf{perfectly planar}.
    That is, for every polygon you can determine $\beta_0$, $\beta_x$, and $\beta_y$ such that $z = \beta_0 + \beta_x x + \beta_y y$ for \emph{all} vertices $(x, y, z)$ representing the given polygon.
  \item\label{itm:non-overlapping} All polygons $P \in \mathcal{P}$ are \textbf{mutually non-overlapping} when projected into the $xy$-plane, the $xy$-plane being the sea level.
\end{enumerate}
These assumptions are in fact \emph{not} satisfied by the Trondheim roof surface polygon dataset, but these issues are rectifiable.
Assumption \ref{itm:flat} is \textit{nearly} satisfied and can be solved by regression with negligible error.
Assumption \ref{itm:non-overlapping} can be solved with a suitable \enquote{conflict resolution} method which determines which polygon should be considered at each pixel location.
These two solutions will be described in more detail later, but for now it is easier to describe the surface normal raster with these assumptions in place.
We will introduce one final assumption:
\begin{enumerate}
  \setcounter{enumi}{2}
  \item \label{itm:simple} All polygons $P \in \mathcal{P}$ are \textbf{simple} polygons without any interior hulls, and are thus representable by a single exterior ring.
   The exterior ring is represented as an ordered sequences of $(x, y, z)$ coordinate tuples, and will therefore be denoted as,
    \begin{equation*}
      P = [(x_1, y_1, z_1), (x_2, y_2, z_2), \dots, (x_{|P|}, y_{|P|}, z_{|P|}), (x_1, y_1, z_1)],
    \end{equation*}
    where $|P|$ denotes the number of \emph{unique} vertices, and where the first and last coordinate tuples are identical in order to close the ring.
\end{enumerate}
Assumption \ref{itm:simple} is solely introduced for notational simplicity.
Keeping track of several linear rings for each polygon will substantially complicate all expressions that will follow.
There is nothing preventing the surface normal raster format for being generalized to polygons with interior hulls, and our implementation does in fact take interior hulls into account when constructing the surface normal raster.

Under the assumption of all polygons in $\mathcal{P}$ being perfectly planar we are able to decompose any polygon $P \in \mathcal{P}$ into two constituent sub-components: its \textit{two-dimensional projection} and its \textit{planar equation}.
The first sub-component is the projection of the polygon into the $xy$-plane, $\project{P}$, making the three-dimensional polygon two-dimensional instead.
This simple projection is simply performed by truncating the $z$-component of each $(x, y, z)$-vertex in the polygon:
\begin{align*}
  \project{P}
  &=
  \project{[(x_1, y_1, z_1), (x_2, y_2, z_2), \dots, (x_{|P|}, y_{|P|}, z_{|P|}), (x_1, y_1, z_1)]}
  \\
  &=
  [(x_1, y_1), (x_2, y_2), \dots, (x_{|P|}, y_{|P|}), (x_1, y_1)]).
\end{align*}
The projection mapping $\project{P}$ is also illustrated in \cref{fig:2d-polygon-projection}.
\begin{figure}
  \centering
  \includegraphics[width=0.66\linewidth]{2d-projection.tikz}
  \caption{%
    Projection of three-dimensional polygon onto $xy$-plane by $\project{\cdot}$.
  }{%
    The three-dimensional polygon is shown in \textcolor{red}{red}, while the two-dimensional projection is shown in \textcolor{blue}{blue}.
  }%
  \label{fig:2d-polygon-projection}
\end{figure}

The second sub-component is the parametric description of the plane on which \emph{all} vertices of the given polygon lies.
Denote this mapping as $\vec{\beta}(P)$ and define it according to the following relationship:
\begin{align*}
  \vec{\beta}(P)
  =
  \begin{bmatrix}
    \beta_0 \\
    \beta_x \\
    \beta_y \\
  \end{bmatrix}
  \text{ such that }
  z = \beta_0 + \beta_x x + \beta_y y \text{ for all } (x, y, z) \in P
\end{align*}
The original three-dimensional polygon can be easily reconstructed in a lossless manner from the two sub-components, as illustrated in \cref{fig:3d-polygon-reconstruction}, while still being a less redundant representation of the polygon.
%
\begin{figure}[H]
  \centering
  \includegraphics{3d-polygon-reconstruction.tikz}
  \caption{%
    The decomposition and reconstruction of a three-dimensional polygon.
  }%
  \label{fig:3d-polygon-reconstruction}
\end{figure}
\noindent
Now the idea is to create two separate rasters, one which represents $\project{P}$ and one which represents $\vec{\beta}(P)$.
The task of rasterizing $\project{P}$ is quite simple, it is a two-dimensional polygon which can be represented as a binary mask as explained earlier.
\begin{align*}
  S_{i,j} &= \begin{cases}
    1, &\text{if there exists } P \in \mathcal{P} \text{ such that } \project{P} \text{ covers } \pixtogeo{i}{j}.\\
    0, &\text{otherwise.}
  \end{cases}
\end{align*}
Where we have defined $\pixtogeo{i}{j}$ as a function that maps array pixel coordinates $(i, j)$ to the respective coordinate in the UTM coordinate system in which the polygons $P \in \mathcal{P}$ are specified.
When it comes to the rasterization of $\planar{P} = {[\beta_0, \beta_x, \beta_y]}^T$, we start by noticing that the \textit{normal vector} of the plane can be constructed from $\planar{P}$:
\begin{equation*}
  \planar{P}
  =
  \begin{bmatrix}
    \beta_0\\
    \beta_x\\
    \beta_y\\
  \end{bmatrix}
  \iff
  \vec{n}\left(\planar{P}\right)
  =
  \frac{1}{\sqrt{\beta_x^2 + \beta_y^2 + 1}}
  \begin{bmatrix}
    -\beta_x\\
    -\beta_y\\
    1
  \end{bmatrix}
\end{equation*}
This relationship between the equation of the plane and the surface normal vector is illustrated in \cref{fig:3d-normal-vector}.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.55\linewidth]{3d-normal-vector.tikz}
  \caption{%
    The relationship between the equation of the plane and the surface normal vector.
  }{%
    The plane is defined by $z = \beta_0 + \beta_x x + \beta_y y$.
    The elements of the parameter vector $\vec{\beta}$ is shown in \textcolor{orange}{orange}, while the normal vector $\vec{n}$ is shown in \textcolor{blue}{blue}.
  }%
  \label{fig:3d-normal-vector}
\end{figure}
\noindent
Given that we can easily determine $\planar{P}$ for any polygon, we now define the following raster format:
\begin{align*}
  N_{i,j} &= \begin{cases}
    \vec{n}\left(\planar{P}\right), &\text{if $\project{P}$ covers } \pixtogeo{i}{j}.\\
    \vec{0} \defeq {[0, 0, 0]}^T, &\text{otherwise.}
  \end{cases}
\end{align*}
This is a raster format consisting of three raster channels as each pixel location $(i, j)$ represents a three-dimensional normal vector.
It should now become apparent why we made assumption \ref{itm:non-overlapping} earlier, that is, all polygons $P \in \mathcal{P}$ should be mutually non-overlapping after being projected by $\project{\cdot}$.
If more than one polygon covers the coordinate $\pixtogeo(i, j)$ the value for $N_{i,j}$ becomes ambiguous.

\newpage
TODO: Lead over into rasterization of decomposition.
\begin{figure}
  \centering
  \includegraphics{3d-polygon-decomposition.tikz}
  \caption{TODO.}
  \label{fig:3d-polygon-decomposition}
\end{figure}

We will now describe the construction of the \enquote{surface normal} raster format, a format intended as a sufficiently representative and targetable surface raster format for roof geometry inference.
Our set of polygons represent roof surfaces in Trondheim, totaling $|\mathcal{P}| = \numsurfaces$.

Our proposed surface raster format, which we will refer to as a \enquote{surface normal} raster, is based on two key assumptions of the polygons.



Decomposition of polygon, and therefore the rasters.

The idea is now to introduce two new raster array types constructed from three-dimensional surface polygons; a $256 \times 256 \times 3$ \textit{surface normal array} $N$ and a $256 \times 256 \times 1$ \textit{surface elevation array} $H$.
The interpretation and construction of these arrays will be explained in this section.
The dataset used in this thesis contains all roof surfaces in the Norwegian municipality of Trondheim.
For now assume that this collection of polygons represents perfectly flat surfaces in three dimensions, all of which are mutually non-overlapping even when projected onto the $xy$-plane.
%
\begin{align*}
  N_{i,j} &= \begin{cases}
    \text{surface normal vector,} &\text{if surface exists at } (i, j).\\
    \vec{0}, &\text{otherwise.}
  \end{cases}
  \\
  Z_{i,j} &= \begin{cases}
    \text{surface elevation at } $(i, j)$ &\text{if surface exists at } (i, j).\\
    -\infty, &\text{otherwise.}
  \end{cases}
\end{align*}
%
In the case of overlapping polygons the choice of polygon to use in order to fill surface normal and elevation values at overlapped coordinates becomes ambiguous.
In the case of polygons which are not perfectly flat, meaning that all vertices are \emph{not} situated perfectly on the same geometric plane, the interpolation of elevation values to the interior of the polygon becomes ambiguous as well.


Our data set consists of a set of flat, planar, three-dimensional polygons.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{interpolation-concepts.tikz}
  \caption{Three-dimensional surface raster values}{%
    Illustration of interpolated altitude values, $Z_{ij}$, and respective surface normal vectors, $N_{ij}$.
    Slice for $i = 1$ and $1 \leq j \leq 4$.
  }
\end{figure}

\begin{align*}
  N: i \times j \rightarrow \vec{n},
  \hspace{2em} & \text{ where } \vec{n} \in \mathbb{R}^3, ||\vec{n}||_2 \in \{0, 1\},
  \text{ and } i, j \in [0, 255].
\end{align*}


\begin{leftbar}
  \begin{itemize}[nosep,leftmargin=*]
    \item Determine geometric plane for all polygons in polygon collection.
    \item For each tile bounding box\ldots
    \begin{itemize}[nosep,leftmargin=0.5cm]
      \item Determine the subset of polygons which intersects the tile bounding box.
      \item Map polygon subset from geographic coordinate system to pixel coordinate system.
      \item For each pixel in rasterized tile\ldots
      \begin{itemize}[nosep,leftmargin=0.5cm]
        \item Determine subset of polygons which intersects the pixel area.
        \item If more than one polygon covers the given pixel coordinate, choose the polygon with the greatest elevation value at that given point.
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{leftbar}

\subsubsection{Notation}

Let $r_{p,i}$ denote a linear ring belonging to a polygon denoted as $P_p$.
The symbol $p$ denotes the \textit{polygon index}, while $i$ denotes the \textit{ring index}.
A ring index of 1 indicates an \textit{exterior ring}, while a ring index of greater than one represents an interior ring.
The polygon $P_p$ can therefore be represented as a sequence of $|P_p| \geq 1$ linear rings,
%
\begin{equation*}
P_p = \{ r_{p,1}, \dots, r_{p, |P_p|}\}
\end{equation*}
%
Linear rings are represented as ordered sequences of $(x, y, z)$ coordinate tuples, assuming that the associated polygon is three-dimensional.
The linear ring can therefore be denoted as
%
\begin{equation*}
  r_{p,i}
  =
  \{
    (x_{p,i,1}, y_{p,i,1}, z_{p,i,1}),
    \dots,
    (x_{p,i,|r_{p, i}|}, y_{p,i,|r_{p, i}|}, z_{p,i,|r_{p, i}|}),
    (x_{p,i,1}, y_{p,i,1}, z_{p,i,1})
  \},
\end{equation*}
%
where the first and last coordinate tuple are identical in order to close the ring.

\subsubsection{R-Tree index}

Denote the indexed collection of three-dimensional polygons $\mathcal{P}$, and assume that the size of the collection is of size $|\mathcal{P}| \gg 1$, i.e. $\mathcal{P} = \{P_1, P_2, \dots, P_{|\mathcal{P}|} \}$.
In our case the collection $\mathcal{P}$ consists of all roof surfaces in the municipality of Trondheim, Norway with $|\mathcal{P}| = \num{293336}$.
We want construct a set of rasterized tiles defined over a respective set of bounding boxes $\mathcal{T} = \{B(\vec{c}_1, \SI{64}{\meter}, \SI{64}{\meter}), B(\vec{c}_2, \SI{64}{\meter}, \SI{64}{\meter}),\allowbreak \dots,\allowbreak B(\vec{c}_{|\mathcal{T}|}, \SI{64}{\meter}, \SI{64}{\meter}) \}$ based on the polygon collection $\mathcal{P}$.
Denote the algorithmic procedure which construct rasterized tiles \texttt{ConstructTile}.
Assume that we \texttt{ConstructTile} and that this procedure accepts a bounding box $B(\vec{c}, w, h)$ and a polygon collection $\mathcal{P}$ as inputs.
The average time complexity of \texttt{ConstructTile} will most likely be at least linearly dependent of the polygon collection size $|\mathcal{P}|$.
%
\begin{equation*}
  \mathcal{P} \cap B(\vec{c}, h, w)
  =
  \left\{
    P \in \mathcal{P} \mid P \cap B(\vec{c}, h, w) \neq \varnothing
  \right\}
\end{equation*}
%
\begin{equation*}
  \texttt{ConstructTile}(B(\vec{c}, h, w),~\mathcal{P})
  \equiv
  \texttt{ConstructTile}(B(\vec{c}, h, w),~\mathcal{P} \cap B(\vec{c}, h, w))
\end{equation*}

\subsubsection{Linear regression}

Now assume that the polygon collection at hand contains three-dimensional polygons which are all approximately planar.
Any $(x, y, z)$ vertex must therefore satisfy the following relationship:
%
\begin{equation*}
  z = \beta_{p,0} + \beta_{p,x} x + \beta_{p,y} y + \varepsilon
\end{equation*}
%
Where $\varepsilon$ is error term due to measurement errors or other type of random data errors.
The distribution of $\varepsilon$ must be investigated further for our dataset, but for the moment assume the error to be normally distributed with zero mean and some unknown variance $\sigma^2$, i.e. $\varepsilon \sim \mathcal{N}(0, \sigma^2)$.
%
The task is now to determine the coefficient vector $\vec{\beta}_p = {[\beta_{p,0}, \beta_{p,x}, \beta_{p,y}]}^T$ which describes the planar polygon surface.
We construct a design matrix $X_p$ consisting of all $(x, y)$ vertex coordinate tuples of the given polygon $P_p$:
%
\begin{equation*}
  X_p
  =
  \begin{bmatrix}
    1 & x_{p,1,1} & y_{p,1,1} \\
    1 & x_{p,1,2} & y_{p,1,2} \\
    \vdots & \vdots & \vdots \\
    1 & x_{p,1,|r_{p,1}|} & y_{p,1,|r_{p,1}|} \\
    1 & x_{p,2,1} & y_{p,2,1} \\
    1 & x_{p,2,2} & y_{p,2,2} \\
    \vdots & \vdots & \vdots \\
    1 & x_{p,|P_p|,|r_{|P_p|}|} & y_{p,|P_p|,|r_{|P_p|}|} \\
  \end{bmatrix}.
\end{equation*}
%
Likewise, a response vector $\vec{z}_p$ is constructed consisting of the respective elevation values associated with the $(x, y)$ tuples:
%
\begin{equation*}
  \vec{z}_p
  =
  \begin{bmatrix}
     z_{p,1,1} \\
     z_{p,1,2} \\
     \vdots \\
     z_{p,1,|r_{p,1}|} \\
     z_{p,2,1} \\
     z_{p,2,2} \\
     \vdots \\
     z_{p,|P_p|,|r_{|P_p|}|} \\
  \end{bmatrix}
\end{equation*}
%
Again, by assuming $\varepsilon \sim \mathcal{N}(0, \sigma^2)$ we construct an ordinary least squares estimator $\widehat{\vec{\beta}}_p $ for $\vec{\beta}_p$:
%
\begin{equation*}
  \widehat{\vec{\beta}}_p
  =
  {\left[
    \widehat{\beta}_{p,0},
    \widehat{\beta}_{p,x},
    \widehat{\beta}_{p,y}
  \right]}^T
  =
  \left( X_p^T X_p \right)^{-1} X_p^T \vec{z}_p
\end{equation*}
%
Interpolated elevation values for arbitrary $(x, y)$ coordinate tuples can now be constructed:
%
\begin{equation*}
  \widehat{z} = \widehat{\beta}_{p,0} + \widehat{\beta}_{p,x} x + \widehat{\beta}_{p,y} y
\end{equation*}
%
Or as an alternative formulation, a linear predictor $\widehat{f}_z$ parametrized according to $\widehat{\vec{\beta}}_p$ can be constructed:
%
\begin{equation*}
  \widehat{f}_z\left(x, y; \widehat{\vec{\beta}}_p\right)
  =
    \widehat{\beta}_{p,0}
    + \widehat{\beta}_{p,x} x
    + \widehat{\beta}_{p,y} y
  =
  \widehat{z}
\end{equation*}
%
Now define the coefficient vector set $\mathcal{B}(x, y)$ which contains all coefficient vectors to polygons that contain the coordinate $(x, y)$ when projected into the $xy$-plane.
More formally,
%
\begin{equation*}
  \mathcal{B}(x, y) = \left\{
    \vec{\beta}_p
    \mid
    (x, y) \in \project{P_p}
  \right\},
\end{equation*}
%
where $\project{P_p}$ is the projection of all polygon vertex coordinates into the $xy$-plane as illustrated in \cref{fig:2d-polygon-projection}.
%
\begin{equation*}
  \vec{\beta}_m(x, y)
  =
  \argmax_{\vec{\beta} \in \mathcal{B}(x, y)}
    \widehat{f}_z(x, y; \vec{\beta})
\end{equation*}
%
\begin{equation*}
  \vec{n}\left(\vec{\beta}\right)
  =
  \frac{%
    1
  }{%
    \sqrt{\beta_x^2 + \beta_y^2 + 1}
  }
  \cdot
  {\left[
    -\beta_{x}, -\beta_{y}, 1
  \right]}^T
\end{equation*}



\begin{algorithm}{Surface interpolation}{alg:surface-interpolation}{Tile bounding box $B(\vec{c}, w, h)$,\\Raster dimensions $H \times W$,\\R-Tree indexed polygon collection.}
\item Construct arrays with temporary placeholder values:
  \begin{itemize}[label=--,leftmargin=0cm]
    \item Normal vector array $N$ of size $H \times W \times 3$ filled with $0$.
    \item Interpolated elevation array $Z$ of size $H \times W \times 1$ filled with $-\infty$.
  \end{itemize}
\item Construct polygon collection $\mathcal{P}$ for given tile extents using R-Tree index.
  Convert polygons to pixel coordinate system.
\item For polygon $P_p = [r_{p0}, r_{p1}, \dots, r_{pn_p}]$ with a single exterior ring, $r_{p0}$, and $n_p$ interior rings, $[r_{p1}, \ldots, r_{pn_p}]$, in polygon collection $\mathcal{P}$.
  \begin{enumerate}[leftmargin=0.5em,label=\textbf{\alph*}]
      % \item The linear ring $r_{pj} = [(x_{pj0}, y_{pj0}, z_{ij0}), \dots, (x_{pjn_{ij}}, y_{ijn_{pj}}, z_{ijn_{pj}})]$.
    \item Construct $M \times 3$ design matrix $X$ populated with pixel coordinates of all \textit{unique} xy-vertices $(1, x_{pij}, y_{pij})$.
        Secondly, construct $M \times 1$ response vector $\vec{y}$ populated with the respective $z_{pij}$ coordinates.
    \item Solve linear regression problem $\vec{\beta}_p = {\left(\beta_0, \beta_x, \beta_y\right)}^T = {\left(X^T X\right)}^{-1} X^T \vec{y}$
    \item Construct polygon surface normal vector $\vec{n}_p$,
      \begin{equation*}
        \vec{n}_p \assign {\left(\beta_x^2 + \beta_y^2 + 1\right)}^{-1/2} \cdot {\left(-\beta_x, -\beta_y, 1\right)}^T,
      \end{equation*}
      where $||\vec{n}_p||_2 = 1$ by construction.
    \item For each pixel coordinate $(i, j)$ contained by the polygon $P_p$ projected onto the 2-dimensional pixel index plane:
      \begin{itemize}[leftmargin=0.5em]
        \item $h \assign \beta_0 + \beta_x j + \beta_y i$. If $h < Z_ij$, continue loop, else\dots
        \item $Z_{ij} \assign h$ and $\left(N_{ijx}, N_{ijy}, N_{ijz}\right) \assign \vec{n}_p$.
      \end{itemize}
    \end{enumerate}
\end{algorithm}
