\begin{wrapfigure}[10]{r}{0.25\textwidth}
  \vspace{-2em}
  \begin{center}
    \includegraphics[width=\linewidth]{3d-roof.tikz}
  \end{center}
  \caption{%
    \\
    Three-dimensional\\polygonal roof.
  }%
  \label{fig:gable-roof}
\end{wrapfigure}

The roof of a given building can be decomposed into a collection of entirely flat polygons.
This is an accurate data decomposition in most cases, with the exception of conic shapes and other surfaces with continuous curvature which cannot be perfectly represented with a finite set of flat polygons.
A \emph{gable roof}\footnote{\textit{Gable roof} -- A roof which consists of two flat roof surfaces which slope in opposite directions. The roof surfaces are connected along the highest, horizontal edge (ridge).}, for instance, can be considered as the set of two flat polygons which when combined accurately represents the roof in its entirety.
Our intent is to construct a machine learning pipeline which is able to identify such three-dimensional roof surfaces from remote sensing data.

Although a set of vectorized, flat polygons is often the most suitable data decomposition for roof data, it is \emph{not} an ideal representation for traditional machine vision data pipelines.
Polygons can consist of an arbitrary number of linear rings, each with an arbitrary number of vertices, where the number depends on the complexity of the shape.
Deep learning model architectures, on the other hand, are often restricted to training on and predicting observations of \emph{consistent} dimensionality.
This is why machine vision architectures most often accept and/or emit spatial information in the form of \emph{rasters}, that is, numeric arrays with consistent dimensions.
In order to reconcile this conflict we now pose the following question:
%
\begin{quotation}
  \enquote{How can an arbitrarily sized set of three-dimensional polygons, all of arbitrary shape and orientation, be accurately represented in the form of a raster?}.
\end{quotation}
%
We will refer to such a raster as a \textit{surface raster} in order to distinguish it from other remote sensing raster types such as aerial photography and LiDAR data.
The ideal surface raster format would allow us to train on and predict roof surfaces in vectorized polygon form, all the while applying the tried and tested techniques from the machine vision literature which mainly concerns itself with rasters.
The careful formulation and construction of this surface raster format is considered one of the most important problems to be solved in order to construct an efficient machine learning pipeline for predicting roof surfaces.
The ideal surface raster format should be both \emph{representative} and \emph{targetable}, that is:
\begin{description}[style=nextline]
  \item[Representative]
    \textit{Converting surface polygons to the surface raster format and then back again incurs negligible loss of information.}
    \\
    Let $V$ denote the domain consisting the surface polygons in vector form, and denote the surface raster domain as $R = \mathbb{R}^{H \times W \times C_R}$, where $C_R$ is the number of channels used by the surface raster format and $H$ and $W$ is the height and width of the surface raster respectively.
    Now define a suitable distance metric $d: V \times V \rightarrow{R}$ which incorporates some notion of the difference in spatial location and orientation between two three-dimensional polygons.
    A \textit{representative} surface raster format allows us to define a mapping from the vector domain to the surface raster domain, $m: V \rightarrow R$, for which there exists a pseudo-inverse $m^{\dagger}$ which minimizes $d(m^{\dagger}(m(P)), P)$ for some weighting over $P \in V$.
  \item[Targetable] 
    \textit{A raster format which is feasible as a modelling target for a machine vision architecture.}
    \\
    Assume $X$ to be a raster array containing $C_X$ channels representing remote sensing data over a given geographic region, i.e. $X \in \mathbb{R}^{H \times W \times C_X}$, and that $P$ denotes the collection of polygons located within the same geographic region.
    We now want to construct a predictor, denoted as $\hat{f}$, which maps from the remote sensing raster data to the surface raster data representation:
    \begin{equation*}
      \hat{f}:
        \mathbb{R}^{H \times W \times C_X}
        \rightarrow
        \mathbb{R}^{H \times W \times C_R}
    \end{equation*}
    Now assume $\hat{f}$ to be parametrized according to the parameter vector $\vec{\theta}$, and denote the parametrized prediction as $\hat{Y} \defeq \hat{f}(X; \vec{\theta})$.
    The intention is that surface raster prediction $\hat{Y}$ generated from remote sensing data should be as similar to the polygon-constructed raster $Y \defeq m(P)$ as possible.
    As with the distance metric $d$ defined previously, we define some suitable differentiable \textit{loss} function $\mathcal{L}: R \times R \rightarrow \mathbb{R}$ which incorporates some notion of difference between two surface rasters.
    The predictor $\hat{f}$ can therefore be parametrized such that this loss function is minimized when evaluated on the predicted surface raster in conjunction with the ground truth surface raster $m(P)$:
    \begin{align*}
      \vec{\theta}_{\mathrm{opt}}
      &=
      \argmin_{\vec{\theta}}
      \sum_{(\hat{Y}, Y)}
      \mathcal{L}\left(
        \hat{Y};
        Y
      \right)
      \\
      &=
      \argmin_{\vec{\theta}}
      \sum_{(X, P)}
      \mathcal{L}\left(
        \hat{f}(X; \vec{\theta});
        m(P)
      \right)
    \end{align*}
    Although it is the surface raster loss function we minimize, it is not what we \emph{really} are interested in.
    The surface raster is in essence only an intermediate data format which is intended to be converted back into the vector domain by the pseuo-inverse $m^{\dagger}$.
    The thought is that if we minimize the difference between $\hat{Y}$ and $Y$, we implicitly minimize the difference between $m^{\dagger}(\hat{Y})$ and $P$.
    This assumes that $\mathcal{L}$ is a good loss surrogate for functional composition $d \circ m^{\dagger}$:
    \begin{equation*}
      d\left(
        m^{\dagger}(m(P)),~
        m^{\dagger}(\hat{f}(X; \vec{\theta}))
      \right)
      \approx
      d\left(
        P,~
        m^{\dagger}(\hat{f}(X; \vec{\theta}))
      \right)
    \end{equation*}
\end{description}

A \emph{perfectly} representative raster format is a format which allows for a mapping which satisfies $m^{\dagger}(m(P)) \equiv P$ for all polygons $P \in V$.
The polygons can be of arbitrary shape complexity which implies that the vector domain, $V$, is infinite-dimensional.
It is therefore impossible to construct a raster which is both perfectly representative \emph{and} of finite size, that is $H, W, C_R < \infty$.
From an information theory perspective we can conclude that $H \times W \times C_R$, the more representative the raster can be become.

\begin{equation*}
  \min_{m, C_R}~
    \sum_{P \in V}
    d\left(
      m^{\dagger}(m(P), P)
    \right)
\end{equation*}

These two considerations are in many ways diametrically opposed to each other.
Unambiguous. Dense and non-sparse.
A perfectly invertible mapping $m$ is impossible due to the dimensions, can not be lossless.
Must be able to combine several polygons and still be invertible.
Decomposition of polygon, and therefore the rasters.

Such pipelines are often constructed to receive and emit \emph{raster} data during training and prediction, not \emph{vector} data.
The problem is that the data available to us is in vector form, while the tools at our disposal thrives on raster data.
We therefore pose the following question: \enquote{how can we accurately represent three-dimensional vectorized polygon in raster format}.

\begin{figure}
  \begin{center}
    \includegraphics{invertible-rasterization.tikz}
  \end{center}
  \vspace{-1.5em}
  \caption{Invertible rasterization}
  \label{fig:invertible-rasterization}
  \vspace{-1.5em}
\end{figure}
We want to construct rasterized data tiles which geographic extent are specified by bounding boxes $B(\vec{c}, w, h)$.
Specifically we construct square tiles of area $\SI{4096}{\meter\squared}$, i.e. $w = h = \SI{64}{\meter}$, which will contain \num{4} raster values per meter, or equivalently, \num{16} raster pixels values per meter squared.
A specific bounding box $B(\vec{c}, \SI{64}{\meter}, \SI{64}{\meter})$ will therefore be represented by a set of $256 \times 256 \times C$ raster arrays consisting of $C$ channels.
These raster arrays will represent different types of GIS data such as RGB aerial photography ($C = 3$), LiDAR elevation data ($C = 1$), or building footprint segmentation masks ($C = 1$).
The idea is now to introduce two new raster array types constructed from three-dimensional surface polygons; a $256 \times 256 \times 3$ \textit{surface normal array} $N$ and a $256 \times 256 \times 1$ \textit{surface elevation array} $H$.
The interpretation and construction of these arrays will be explained in this section.
The dataset used in this thesis contains all roof surfaces in the Norwegian municipality of Trondheim.
For now assume that this collection of polygons represents perfectly flat surfaces in three dimensions, all of which are mutually non-overlapping even when projected onto the $xy$-plane.
%
\begin{align*}
  N_{i,j} &= \begin{cases}
    \text{surface normal vector,} &\text{if surface exists at } (i, j).\\
    \vec{0}, &\text{otherwise.}
  \end{cases}
  \\
  Z_{i,j} &= \begin{cases}
    \text{surface elevation at } $(i, j)$ &\text{if surface exists at } (i, j).\\
    -\infty, &\text{otherwise.}
  \end{cases}
\end{align*}
%
In the case of overlapping polygons the choice of polygon to use in order to fill surface normal and elevation values at overlapped coordinates becomes ambiguous.
In the case of polygons which are not perfectly flat, meaning that all vertices are \emph{not} situated perfectly on the same geometric plane, the interpolation of elevation values to the interior of the polygon becomes ambiguous as well.

Our data set consists of a set of flat, planar, three-dimensional polygons.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{interpolation-concepts.tikz}
  \caption{Three-dimensional surface raster values}{%
    Illustration of interpolated altitude values, $Z_{ij}$, and respective surface normal vectors, $N_{ij}$.
    Slice for $i = 1$ and $1 \leq j \leq 4$.
  }
\end{figure}

\begin{align*}
  N: i \times j \rightarrow \vec{n},
  \hspace{2em} & \text{ where } \vec{n} \in \mathbb{R}^3, ||\vec{n}||_2 \in \{0, 1\},
  \text{ and } i, j \in [0, 255].
\end{align*}


\begin{leftbar}
  \begin{itemize}[nosep,leftmargin=*]
    \item Determine geometric plane for all polygons in polygon collection.
    \item For each tile bounding box\ldots
    \begin{itemize}[nosep,leftmargin=0.5cm]
      \item Determine the subset of polygons which intersects the tile bounding box.
      \item Map polygon subset from geographic coordinate system to pixel coordinate system.
      \item For each pixel in rasterized tile\ldots
      \begin{itemize}[nosep,leftmargin=0.5cm]
        \item Determine subset of polygons which intersects the pixel area.
        \item If more than one polygon covers the given pixel coordinate, choose the polygon with the greatest elevation value at that given point.
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{leftbar}

\subsubsection{Notation}

Let $r_{p,i}$ denote a linear ring belonging to a polygon denoted as $P_p$.
The symbol $p$ denotes the \textit{polygon index}, while $i$ denotes the \textit{ring index}.
A ring index of 1 indicates an \textit{exterior ring}, while a ring index of greater than one represents an interior ring.
The polygon $P_p$ can therefore be represented as a sequence of $|P_p| \geq 1$ linear rings,
%
\begin{equation*}
P_p = \{ r_{p,1}, \dots, r_{p, |P_p|}\}
\end{equation*}
%
Linear rings are represented as ordered sequences of $(x, y, z)$ coordinate tuples, assuming that the associated polygon is three-dimensional.
The linear ring can therefore be denoted as
%
\begin{equation*}
  r_{p,i}
  =
  \{
    (x_{p,i,1}, y_{p,i,1}, z_{p,i,1}),
    \dots,
    (x_{p,i,|r_{p, i}|}, y_{p,i,|r_{p, i}|}, z_{p,i,|r_{p, i}|}),
    (x_{p,i,1}, y_{p,i,1}, z_{p,i,1})
  \},
\end{equation*}
%
where the first and last coordinate tuple are identical in order to close the ring.

\subsubsection{R-Tree index}

Denote the indexed collection of three-dimensional polygons $\mathcal{P}$, and assume that the size of the collection is of size $|\mathcal{P}| \gg 1$, i.e. $\mathcal{P} = \{P_1, P_2, \dots, P_{|\mathcal{P}|} \}$.
In our case the collection $\mathcal{P}$ consists of all roof surfaces in the municipality of Trondheim, Norway with $|\mathcal{P}| = \num{293336}$.
We want construct a set of rasterized tiles defined over a respective set of bounding boxes $\mathcal{T} = \{B(\vec{c}_1, \SI{64}{\meter}, \SI{64}{\meter}), B(\vec{c}_2, \SI{64}{\meter}, \SI{64}{\meter}),\allowbreak \dots,\allowbreak B(\vec{c}_{|\mathcal{T}|}, \SI{64}{\meter}, \SI{64}{\meter}) \}$ based on the polygon collection $\mathcal{P}$.
Denote the algorithmic procedure which construct rasterized tiles \texttt{ConstructTile}.
Assume that we \texttt{ConstructTile} and that this procedure accepts a bounding box $B(\vec{c}, w, h)$ and a polygon collection $\mathcal{P}$ as inputs.
The average time complexity of \texttt{ConstructTile} will most likely be at least linearly dependent of the polygon collection size $|\mathcal{P}|$.
%
\begin{equation*}
  \mathcal{P} \cap B(\vec{c}, h, w)
  =
  \left\{
    P \in \mathcal{P} \mid P \cap B(\vec{c}, h, w) \neq \varnothing
  \right\}
\end{equation*}
%
\begin{equation*}
  \texttt{ConstructTile}(B(\vec{c}, h, w),~\mathcal{P})
  \equiv
  \texttt{ConstructTile}(B(\vec{c}, h, w),~\mathcal{P} \cap B(\vec{c}, h, w))
\end{equation*}

\subsubsection{Linear regression}

Now assume that the polygon collection at hand contains three-dimensional polygons which are all approximately planar.
Any $(x, y, z)$ vertex must therefore satisfy the following relationship:
%
\begin{equation*}
  z = \beta_{p,0} + \beta_{p,x} x + \beta_{p,y} y + \varepsilon
\end{equation*}
%
Where $\varepsilon$ is error term due to measurement errors or other type of random data errors.
The distribution of $\varepsilon$ must be investigated further for our dataset, but for the moment assume the error to be normally distributed with zero mean and some unknown variance $\sigma^2$, i.e. $\varepsilon \sim \mathcal{N}(0, \sigma^2)$.
%
The task is now to determine the coefficient vector $\vec{\beta}_p = {[\beta_{p,0}, \beta_{p,x}, \beta_{p,y}]}^T$ which describes the planar polygon surface.
We construct a design matrix $X_p$ consisting of all $(x, y)$ vertex coordinate tuples of the given polygon $P_p$:
%
\begin{equation*}
  X_p
  =
  \begin{bmatrix}
    1 & x_{p,1,1} & y_{p,1,1} \\
    1 & x_{p,1,2} & y_{p,1,2} \\
    \vdots & \vdots & \vdots \\
    1 & x_{p,1,|r_{p,1}|} & y_{p,1,|r_{p,1}|} \\
    1 & x_{p,2,1} & y_{p,2,1} \\
    1 & x_{p,2,2} & y_{p,2,2} \\
    \vdots & \vdots & \vdots \\
    1 & x_{p,|P_p|,|r_{|P_p|}|} & y_{p,|P_p|,|r_{|P_p|}|} \\
  \end{bmatrix}.
\end{equation*}
%
Likewise, a response vector $\vec{z}_p$ is constructed consisting of the respective elevation values associated with the $(x, y)$ tuples:
%
\begin{equation*}
  \vec{z}_p
  =
  \begin{bmatrix}
     z_{p,1,1} \\
     z_{p,1,2} \\
     \vdots \\
     z_{p,1,|r_{p,1}|} \\
     z_{p,2,1} \\
     z_{p,2,2} \\
     \vdots \\
     z_{p,|P_p|,|r_{|P_p|}|} \\
  \end{bmatrix}
\end{equation*}
%
Again, by assuming $\varepsilon \sim \mathcal{N}(0, \sigma^2)$ we construct an ordinary least squares estimator $\widehat{\vec{\beta}}_p $ for $\vec{\beta}_p$:
%
\begin{equation*}
  \widehat{\vec{\beta}}_p
  =
  {\left[
    \widehat{\beta}_{p,0},
    \widehat{\beta}_{p,x},
    \widehat{\beta}_{p,y}
  \right]}^T
  =
  \left( X_p^T X_p \right)^{-1} X_p^T \vec{z}_p
\end{equation*}
%
Interpolated elevation values for arbitrary $(x, y)$ coordinate tuples can now be constructed:
%
\begin{equation*}
  \widehat{z} = \widehat{\beta}_{p,0} + \widehat{\beta}_{p,x} x + \widehat{\beta}_{p,y} y
\end{equation*}
%
Or as an alternative formulation, a linear predictor $\widehat{f}_z$ parametrized according to $\widehat{\vec{\beta}}_p$ can be constructed:
%
\begin{equation*}
  \widehat{f}_z\left(x, y; \widehat{\vec{\beta}}_p\right)
  =
    \widehat{\beta}_{p,0}
    + \widehat{\beta}_{p,x} x
    + \widehat{\beta}_{p,y} y
  =
  \widehat{z}
\end{equation*}
%
Now define the coefficient vector set $\mathcal{B}(x, y)$ which contains all coefficient vectors to polygons that contain the coordinate $(x, y)$ when projected into the $xy$-plane.
More formally,
%
\begin{equation*}
  \mathcal{B}(x, y) = \left\{
    \vec{\beta}_p
    \mid
    (x, y) \in \pi_{\mathrm{2D}}(P_p)
  \right\},
\end{equation*}
%
where $\pi_{\mathrm{2D}}$ is the projection of all polygon vertex coordinates into the $xy$-plane as illustrated in \cref{fig:2d-polygon-projection}.
%
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{2d-projection.tikz}
  \caption{%
    Projection of three-dimensional polygon onto $xy$-plane by $\pi_{\mathrm{2D}}$.
  }{%
    The three-dimensional polygon is shown in \textcolor{red}{red}, while the two-dimensional projection is shown in \textcolor{blue}{blue}.
  }%
  \label{fig:2d-polygon-projection}
\end{figure}
%
\begin{equation*}
  \vec{\beta}_m(x, y)
  =
  \argmax_{\vec{\beta} \in \mathcal{B}(x, y)}
    \widehat{f}_z(x, y; \vec{\beta})
\end{equation*}
%
\begin{equation*}
  \vec{n}\left(\vec{\beta}\right)
  =
  \frac{%
    1
  }{%
    \sqrt{\beta_x^2 + \beta_y^2 + 1}
  }
  \cdot
  {\left[
    -\beta_{x}, -\beta_{y}, 1
  \right]}^T
\end{equation*}



\begin{algorithm}{Surface interpolation}{alg:surface-interpolation}{Tile bounding box $B(\vec{c}, w, h)$,\\Raster dimensions $H \times W$,\\R-Tree indexed polygon collection.}
\item Construct arrays with temporary placeholder values:
  \begin{itemize}[label=--,leftmargin=0cm]
    \item Normal vector array $N$ of size $H \times W \times 3$ filled with $0$.
    \item Interpolated elevation array $Z$ of size $H \times W \times 1$ filled with $-\infty$.
  \end{itemize}
\item Construct polygon collection $\mathcal{P}$ for given tile extents using R-Tree index.
  Convert polygons to pixel coordinate system.
\item For polygon $P_p = [r_{p0}, r_{p1}, \dots, r_{pn_p}]$ with a single exterior ring, $r_{p0}$, and $n_p$ interior rings, $[r_{p1}, \ldots, r_{pn_p}]$, in polygon collection $\mathcal{P}$.
  \begin{enumerate}[leftmargin=0.5em,label=\textbf{\alph*}]
      % \item The linear ring $r_{pj} = [(x_{pj0}, y_{pj0}, z_{ij0}), \dots, (x_{pjn_{ij}}, y_{ijn_{pj}}, z_{ijn_{pj}})]$.
    \item Construct $M \times 3$ design matrix $X$ populated with pixel coordinates of all \textit{unique} xy-vertices $(1, x_{pij}, y_{pij})$.
        Secondly, construct $M \times 1$ response vector $\vec{y}$ populated with the respective $z_{pij}$ coordinates.
    \item Solve linear regression problem $\vec{\beta}_p = {\left(\beta_0, \beta_x, \beta_y\right)}^T = {\left(X^T X\right)}^{-1} X^T \vec{y}$
    \item Construct polygon surface normal vector $\vec{n}_p$,
      \begin{equation*}
        \vec{n}_p \assign {\left(\beta_x^2 + \beta_y^2 + 1\right)}^{-1/2} \cdot {\left(-\beta_x, -\beta_y, 1\right)}^T,
      \end{equation*}
      where $||\vec{n}_p||_2 = 1$ by construction.
    \item For each pixel coordinate $(i, j)$ contained by the polygon $P_p$ projected onto the 2-dimensional pixel index plane:
      \begin{itemize}[leftmargin=0.5em]
        \item $h \assign \beta_0 + \beta_x j + \beta_y i$. If $h < Z_ij$, continue loop, else\dots
        \item $Z_{ij} \assign h$ and $\left(N_{ijx}, N_{ijy}, N_{ijz}\right) \assign \vec{n}_p$.
      \end{itemize}
    \end{enumerate}
\end{algorithm}
